```c++
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* l;
    TreeNode* r;
    TreeNode(int x) : val(x), l(nullptr), r(nullptr) {}
};

// 将数组（层序遍历格式）转换为二叉树，-1 表示空节点
TreeNode* listToTree(vector<int>& arr) {
    if (arr.empty() || arr[0] == -1) return nullptr;

    TreeNode* root = new TreeNode(arr[0]);
    queue<TreeNode*> q;
    q.push(root);

    int i = 1;
    while (i < arr.size() && !q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        // 左子节点
        if (i < arr.size() && arr[i] != -1) {
            node->l = new TreeNode(arr[i]);
            q.push(node->l);
        }
        i++;

        // 右子节点
        if (i < arr.size() && arr[i] != -1) {
            node->r = new TreeNode(arr[i]);
            q.push(node->r);
        }
        i++;
    }

    return root;
}

// 层序遍历，按层返回二维数组
vector<vector<int>> order(TreeNode* root) {
    vector<vector<int>> res;
    if (!root) return res;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();  // 当前层的节点数
        vector<int> currentLevel;

        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node->val);

            if (node->l) q.push(node->l);
            if (node->r) q.push(node->r);
        }

        res.push_back(currentLevel);
    }

    return res;
}

// 打印结果
void printResult(const vector<vector<int>>& res) {
    for (const auto& level : res) {
        cout << "[ ";
        for (int val : level) {
            cout << val << " ";
        }
        cout << "]" << endl;
    }
}

int main() {
    vector<int> list = {3, 9, 20, -1, -1, 15, 7};  // -1 表示空节点
    TreeNode* root = listToTree(list);

    vector<vector<int>> res = order(root);
    printResult(res);

    return 0;
}
```
