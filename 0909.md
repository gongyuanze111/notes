socket的套接字有哪些参数，send缓冲区是干什么的，为什么udp也有

一、创建 socket 时常见的 3 个参数  
```c
int socket(int domain, int type, int protocol);
```
1. domain（协议族）  
   • AF_INET   → IPv4  
   • AF_INET6  → IPv6  
   • AF_UNIX   → 本机进程间通信  
2. type（套接字类型）  
   • SOCK_STREAM → 字节流（TCP）  
   • SOCK_DGRAM  → 数据报（UDP）  
   • SOCK_RAW    → 原始 IP 包  
3. protocol（具体协议号，通常填 0 让内核按前两项默认）  
   • 0  
   • IPPROTO_TCP (=6)  
   • IPPROTO_UDP (=17)

（还有不常用的 `SOCK_SEQPACKET`、`SOCK_RDM` 等，此处略。）

二、send 缓冲区是什么  
内核为 **每个已连接的 socket** 维护一块 **发送缓冲区**（tx buffer）。  
- 用户调用 `send()/write()` 时，数据先拷进该缓冲区，内核随后按 TCP/UDP 规则真正发到网卡。  
- 若缓冲区已满，`send()` 会阻塞（或返回 `EAGAIN`）。  
- 大小可调：  
  ```bash
  # 查看
  cat /proc/sys/net/core/wmem_default   # 默认 212 KiB 左右
  cat /proc/sys/net/core/wmem_max       # 上限
  # 单个 socket 动态调整
  setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size));
  ```

三、为什么 UDP 也有 send 缓冲区  
虽然 UDP “无连接、无重传”，但内核仍需：  
1. **暂存数据**：用户一次 `sendto()` 的数据可能大于 MTU，IP 层需要分片；缓冲区保证分片期间数据不丢。  
2. **异步发送**：应用写完立即返回，内核稍后把报文交给网卡，减少用户态/内核态切换。  
3. **流量整形/限速**：QoS、TC 规则在缓冲区排队。  
4. **多播/广播复制**：一次写入多次发送，也需要缓冲。

因此，UDP socket 同样拥有 **send 缓冲区**，只是语义简单：  
- 报文一次性发出，缓冲区只保留到 IP 层取走为止；  
- 不会像 TCP 那样因 ACK 未达而重传。

socket说明 https://blog.csdn.net/weixin_73494835/article/details/140806340?ops_request_misc=%257B%2522request%255Fid%2522%253A%252284a7038ba1f63f30a260ab1ca6184dc8%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=84a7038ba1f63f30a260ab1ca6184dc8&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-140806340-null-null.142^v102^pc_search_result_base7&utm_term=socket&spm=1018.2226.3001.4187

为什么 TCP 常用 send/recv

TCP 三次握手后 socket 已“连接”，内核记录了对端地址，因此后续收发无需再传地址。
为什么 UDP 常用 sendto/recvfrom

UDP 无连接，每次收发都可能是不同对端，必须显式指定/返回地址；
即使 UDP 调用了 connect()，也仍可使用 send/recv，但那只是“固定对端”，失去了 UDP 可多对端的灵活性，所以大多数示例仍用 sendto/recvfrom。

一句话先给结论：  
C++ 中“继承＋多态”靠 **虚函数表（vtable）＋虚函数指针（vptr）** 实现；**编译时**把函数地址写进表，**运行时**根据对象真实类型查表调用，于是**基类指针/引用**能正确找到**派生类重写**的函数。

----------------------------
一、继承的静态模型  
1. 对象内存 = 父类成员 + 子类成员  
   ```
   class Base { int a; };      // 4 字节
   class Derived : public Base { int b; }; // 8 字节：|a|b|
   ```
2. 类型转换  
   - 上行（derived→base）安全、无需转换；下行需 `dynamic_cast` 并检查。

----------------------------
二、多态的底层三件套  
1. **虚函数表 vtable**（编译期生成，放在只读数据段）  
   ```
   class Base {
   public:
       virtual void foo() { /*addr0*/ }
       virtual ~Base()    { /*addr1*/ }
   };
   ```
   生成的 vtable：  
   ```
   Base::vtable[0] = &Base::foo
   Base::vtable[1] = &Base::~Base
   ```

2. **vptr（隐藏指针）**  
   每个有虚函数的类，对象头部自动插入一个指针（32/64 位机器各 4/8 字节）。  
   ```
   | vptr | Base::a | Base::b | ... |
   ```
   构造时把 vptr 指向“本类”的 vtable。

3. **运行时查表**  
   ```
   Base* p = new Derived;
   p->foo();          // 生成汇编：(*(p->vptr)[index])();
   ```
   因为 p 指向 Derived 对象，它的 vptr 指向 Derived::vtable，于是调用派生版本。

----------------------------
三、代码示例：完整链路

```
#include <iostream>
class Base {
public:
    virtual void speak() { std::cout << "Base\n"; }
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    void speak() override { std::cout << "Derived\n"; }
};

int main() {
    Base* p = new Derived;
    p->speak();         // 输出 Derived
    delete p;
}
```

- 编译阶段：为 Base、Derived 各生成一张 vtable。  
- 运行阶段：  
  1. new Derived → vptr = &Derived::vtable。  
  2. p->speak() → `(*(p->vptr)[0])()` → 实际执行 Derived::speak。

----------------------------
四、常见细节

| 问题 | 说明 |
|---|---|
| 纯虚函数 | `virtual void f() = 0;` ⇒ 类带纯虚函数，vtable 对应项填 0，使类抽象。 |
| 菱形继承 | 使用 **虚继承** (`class A : virtual public B`) 解决重复基类子对象。 |
| 动态绑定开销 | 一次额外指针解引用，一般可忽略；虚析构防内存泄漏必写。 |
| 非虚函数 | 在编译期直接确定地址，**静态绑定**，无 vtable 参与。 |

----------------------------
一句话总结：  
多态 = **虚函数表 + vptr + 运行时查表**；编译器把“哪个函数”的决定延迟到真正知道对象类型那一刻。

mt2面-究极拷打，语速极快，态度一般，全程围绕项目，rag和agent
疯狂让我举例子，
RAG做了什么优化，benchmark有哪些类型，如何构建的，举benchmark例子和得到提升的例子
重排序模型是咋用的
比赛，举一个embedding从BM25角度得到优化的例子，RL怎么做的，评价为更像RL，基于规则
构建QA时用知识图谱而问答时不用graphrag，为什么，graphrag优点缺点

Debug Agent项目，各部分功能介绍，工具介绍，用没用多Agent，IssueAgent举例子，
主流的三个Agent框架，langchain/langgraph， CrewAI，AutoGen， Swarm
agentscope与之区别，或与哪个比较像，agentscope特点，功能
Agentic RAG与RAG的区别

反问环节
1.业务场景-字节SEED&Flow中的那个flow，各种大模型数据分析
2.工作强度-早10晚9.5
