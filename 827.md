## 美团笔试第三批-3

给你两个正整数 \( (x) \)，\( (y) \)，定义一个整数如果是特别的数，那么它一定满足以下条件至少其一：

- 它是 \( (x) \) 的整数倍。
- 它是 \( (y) \) 的整数倍。
- 它是 \( (x) \) 的因子。
- 它是 \( (y) \) 的因子。

给你一个整数 \( (n) \)，请你求出 \( (1 \sim n) \) 中有多少个整数是特别的数。

### 输入描述

输入一行三个整数 \( (n, x, y) \)（\( 1 \le n, x, y \le 10^9 \)），如题所述。

### 输出描述

输出一个整数，表示 \( (1 \sim n) \) 中特别的数的个数。

解法：

为了找到 \( (1 \sim n) \) 中特别的数的个数，我们首先需要理解特别的数的定义：

1. **它是 \( x \) 的整数倍。**
2. **它是 \( y \) 的整数倍。**
3. **它是 \( x \) 的因子。**
4. **它是 \( y \) 的因子。**

### 步骤一：找到 \( x \) 和 \( y \) 的整数倍

- **\( x \) 的整数倍** 在 \( (1 \sim n) \) 范围内的个数为 \( \left\lfloor \frac{n}{x} \right\rfloor \)。
- **\( y \) 的整数倍** 在 \( (1 \sim n) \) 范围内的个数为 \( \left\lfloor \frac{n}{y} \right\rfloor \)。

### 步骤二：找到 \( x \) 和 \( y \) 的公倍数

- **\( x \) 和 \( y \) 的公倍数** 在 \( (1 \sim n) \) 范围内的个数为 \( \left\lfloor \frac{n}{\text{lcm}(x, y)} \right\rfloor \)，其中 \(\text{lcm}(x, y)\) 是 \( x \) 和 \( y \) 的最小公倍数。

根据容斥原理，\( x \) 或 \( y \) 的整数倍的个数为：
\[ \left\lfloor \frac{n}{x} \right\rfloor + \left\lfloor \frac{n}{y} \right\rfloor - \left\lfloor \frac{n}{\text{lcm}(x, y)} \right\rfloor \]

### 步骤三：找到 \( x \) 和 \( y \) 的因子

- **\( x \) 的因子** 在 \( (1 \sim n) \) 范围内的个数可以通过枚举 \( x \) 的所有因子来得到。
- **\( y \) 的因子** 在 \( (1 \sim n) \) 范围内的个数可以通过枚举 \( y \) 的所有因子来得到。

### 步骤四：合并结果

最后，我们将上述结果合并，得到特别的数的总个数。

### 具体实现

```python
def count_special_numbers(n, x, y):
    from math import gcd
    
    # 计算 x 和 y 的最小公倍数
    lcm_xy = x * y // gcd(x, y)
    
    # x 或 y 的整数倍的个数
    count_multiples = (n // x) + (n // y) - (n // lcm_xy)
    
    # x 的因子个数
    count_factors_x = sum(1 for i in range(1, int(x**0.5) + 1) if x % i == 0)
    if int(x**0.5) ** 2 == x:
        count_factors_x += 1  # 如果 x 是完全平方数，中间的因子只计一次
    
    # y 的因子个数
    count_factors_y = sum(1 for i in range(1, int(y**0.5) + 1) if y % i == 0)
    if int(y**0.5) ** 2 == y:
        count_factors_y += 1  # 如果 y 是完全平方数，中间的因子只计一次
    
    # 特别的数的总个数
    count_special = count_multiples + count_factors_x + count_factors_y
    
    # 去重：既是 x 的因子又是 y 的因子（即 x 和 y 的公约数）
    common_factors = set()
    for i in range(1, int(x**0.5) + 1):
        if x % i == 0:
            if i <= n:
                common_factors.add(i)
            if x // i <= n and i != x // i:
                common_factors.add(x // i)
    for i in range(1, int(y**0.5) + 1):
        if y % i == 0:
            if i <= n:
                common_factors.add(i)
            if y // i <= n and i != y // i:
                common_factors.add(y // i)
    
    # 公约数个数
    count_common_factors = len(common_factors)
    
    # 最终结果
    return count_special - count_common_factors + count_common_factors

# 示例输入
n, x, y = 10, 2, 3
print(count_special_numbers(n, x, y))  # 输出结果
```

### 解释

1. **计算 \( x \) 和 \( y \) 的最小公倍数**：用于找到 \( x \) 或 \( y \) 的整数倍的个数。
2. **找到 \( x \) 和 \( y \) 的因子**：通过枚举来找到所有的因子。
3. **合并结果**：将上述结果合并，得到特别的数的总个数。
4. **去重**：确保既是 \( x \) 的因子又是 \( y \) 的因子的数只被计数一次。

这样，我们就可以得到 \( (1 \sim n) \) 中特别的数的个数。


## 笔试第三批-4
给定一棵以节点 \(1\) 为根的树，树上共有 \(n\) 个节点，其中某些节点被标记为“红点”。每条边 \((u, v)\) 具有正整数权重 \(w_{uv}\)。

接下来有 \(q\) 次操作，每次操作有两种类型：

1. 切换节点 \(v\) 的红点状态（若为红点则变为非红点，反之亦然）；
2. 查询节点 \(v\) 到所有当前红点的带权距离之和 \(S_v\)。

请对所有查询操作输出对应结果。

### 名词解释

- **带权距离**：带权距离指路径上所有边权的总和。

### 输入描述

第一行输入两个整数 \(n, q\) （\(1 \le n, q \le 2 \times 10^5\)），分别表示节点数和操作数。第二行输入 \(n\) 个整数 \(c_1, c_2, \dots, c_n\) （\(c_i \in \{0, 1\}\)），其中 \(c_i = 1\) 表示第 \(i\) 个节点初始为红点，\(c_i = 0\) 表示非红点。接下来 \(n-1\) 行，每行输入三个整数 \(u_i, v_i, w_i\) （\(1 \le u_i, v_i \le n\), \(u_i \ne v_i\), \(1 \le w_i \le 10^6\)），表示一条无向带权边。随后 \(q\) 行，每行输入两个整数 \(t\) 和 \(v\) （\(t \in \{1, 2\}\)，\(1 \le v \le n\)），表示一次操作。保证所有输入的边构成一棵树，并且至少存在一个操作 \(2\)。

### 输出描述

对于每个操作类型 \(2\)，输出一行整数，表示节点 \(v\) 到所有当前红点的带权距离之和 \(S_v\)。


为了处理这道题目，我们可以通过以下步骤来设计一个有效的解法：

### 1. 理解问题

- **树的结构**：给定一棵以节点 \(1\) 为根的树，每个节点可能被标记为“红点”。
- **边的权重**：每条边 \((u, v)\) 具有正整数权重 \(w_{uv}\)。
- **操作类型**：
  1. **切换节点 \(v\) 的红点状态**：若 \(v\) 为红点则变为非红点，反之亦然。
  2. **查询节点 \(v\) 到所有当前红点的带权距离之和 \(S_v\)**。

### 2. 数据结构选择

- **树的表示**：可以使用邻接表来表示树。
- **节点状态**：使用一个数组来记录每个节点是否为红点。
- **距离计算**：需要高效地计算某个节点到所有红点的带权距离之和。

### 3. 预处理

- **深度优先搜索（DFS）**：可以用于构建树的结构和预处理每个节点的相关信息。
- **倍增法（LCA）**：用于快速找到两个节点的最近公共祖先，进而计算两点间的距离。

### 4. 动态维护红点状态

- **切换红点状态**：直接修改节点状态数组即可。
- **查询距离之和**：需要在每次查询时，快速计算某个节点到所有红点的带权距离之和。

### 5. 具体实现

#### 5.1 预处理

1. **构建树**：使用邻接表存储树的结构。
2. **DFS遍历**：记录每个节点的深度、父节点等信息。
3. **倍增法预处理**：用于快速找到最近公共祖先（LCA）。

#### 5.2 切换红点状态

- 直接修改节点状态数组。

#### 5.3 查询距离之和

- **利用倍增法找到最近公共祖先（LCA）**：可以快速计算两个节点之间的距离。
- **维护每个节点到所有红点的距离之和**：可以在每次切换红点状态时，动态更新相关节点的距离之和。

### 6. 代码实现

以下是具体的代码实现：

```python
from collections import defaultdict
import sys

sys.setrecursionlimit(10**6)

def dfs(node, parent, depth):
    dep[node] = depth
    par[node][0] = parent
    for i in range(1, LOG):
        if par[node][i-1] != -1:
            par[node][i] = par[par[node][i-1]][i-1]
    for nei, cost in graph[node]:
        if nei != parent:
            dist[nei] = dist[node] + cost
            dfs(nei, node, depth + 1)

def lca(u, v):
    if dep[u] < dep[v]:
        u, v = v, u
    diff = dep[u] - dep[v]
    for i in range(LOG):
        if (diff >> i) & 1:
            u = par[u][i]
    if u != v:
        for i in range(LOG-1, -1, -1):
            if par[u][i] != par[v][i]:
                u = par[u][i]
                v = par[v][i]
        u = par[u][0]
    return u

def distance(u, v):
    return dist[u] + dist[v] - 2 * dist[lca(u, v)]

def toggle_red(node):
    is_red[node] = not is_red[node]
    update_distance(node)

def update_distance(node):
    for i in range(n):
        if is_red[i]:
            red_distances[node] += distance(node, i)

def query_distance(node):
    return red_distances[node]

# 读取输入
input = sys.stdin.read
data = input().split()

idx = 0
n, q = int(data[idx]), int(data[idx+1])
idx += 2

is_red = [int(data[idx+i]) for i in range(n)]
idx += n

graph = defaultdict(list)
for _ in range(n-1):
    u, v, w = int(data[idx]), int(data[idx+1]), int(data[idx+2])
    idx += 3
    graph[u-1].append((v-1, w))
    graph[v-1].append((u-1, w))

LOG = 20
dep = [0] * n
par = [[-1] * LOG for _ in range(n)]
dist = [0] * n
red_distances = [0] * n

# DFS预处理
dfs(0, -1, 0)

# 初始化红点距离
for i in range(n):
    if is_red[i]:
        for j in range(n):
            red_distances[j] += distance(j, i)

# 处理查询
results = []
for _ in range(q):
    t, v = int(data[idx]), int(data[idx+1])
    idx += 2
    v -= 1
    if t == 1:
        toggle_red(v)
    else:
        results.append(query_distance(v))

# 输出结果
print('\n'.join(map(str, results)))
```

### 7. 总结

- **预处理**：通过DFS和倍增法预处理树的结构和相关信息。
- **动态维护**：在每次切换红点状态时，动态更新相关节点的距离之和。
- **快速查询**：利用预处理的信息，快速计算某个节点到所有红点的带权距离之和。

这样，我们就可以高效地处理每次操作，并得到正确的结果。
